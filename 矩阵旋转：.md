### 一、矩阵顺时针旋转90度：
##### 1.最外层的移动：
[![vqLAwq.png](https://s1.ax1x.com/2022/09/09/vqLAwq.png)](https://imgse.com/i/vqLAwq)对于上面这个5 x 5的矩阵旋转90度之后的结果是：[![vqLYtK.png](https://s1.ax1x.com/2022/09/09/vqLYtK.png)](https://imgse.com/i/vqLYtK)我们可以发现，旋转90度之后，上面所标注的四个元素正好循环交替位置，因此我们可以把整个矩阵的旋转问题转换成元素顺时针移动的问题。
- 我们可以想一下，每一次我们都移动四个元素，把这四个元素当成一组，那么我们需要移动多少组呢？第一组从A开始，下标为[0],[0]，元素E的下标为[0],[4]，因此每个元素之间间隔4个位置。并且我们可以发现，这四个元素正好构成了一个正方形。
[![vqOGuj.png](https://s1.ax1x.com/2022/09/09/vqOGuj.png)](https://imgse.com/i/vqOGuj)第二组我们从B开始移动，正好构成一个正方形。[![vqOwCT.png](https://s1.ax1x.com/2022/09/09/vqOwCT.png)](https://imgse.com/i/vqOwCT)第三组我们从C开始移动，正好构成一个正方形。[![vqOB2F.png](https://s1.ax1x.com/2022/09/09/vqOB2F.png)](https://imgse.com/i/vqOB2F)第四组我们从D开始移动，正好构成一个正方形。
- 至此我们就把最外侧的部分全部移动完成：
[![vqObVI.png](https://s1.ax1x.com/2022/09/09/vqObVI.png)](https://imgse.com/i/vqObVI)
##### 2.里层移动：
- 接下来，我们对矩阵的第二层进行元素的移动。[![vqX9qs.png](https://s1.ax1x.com/2022/09/09/vqX9qs.png)](https://imgse.com/i/vqX9qs)这里面我们需要注意，类比第一层，我们同样是按照正方形的规则进行元素的移动，只不过现在元素之间的间隔不再是4，而是现在的2。
- 进行第一组移动，从G开始，按照顺时针顺序：[![vqX9qs.png](https://s1.ax1x.com/2022/09/09/vqX9qs.png)](https://imgse.com/i/vqX9qs)
- 接着进行第二组元素的移动：[![vqXVRU.png](https://s1.ax1x.com/2022/09/09/vqXVRU.png)](https://imgse.com/i/vqXVRU)至此我们就把整个矩阵进行了旋转操作。
##### 3.算法总结：
通过上面的分析我们可以得出：
- 矩阵的旋转过程等价为元素的移动过程。
- 元素的移动分层进行，对于n阶的矩阵，其层数为n / 2层，(这里的除法默认截断小数部分)。因此我们可以设置循环来进行分层处理。
- 在每一层的处理中，我们是通过对元素分组来进行移动的，每一组元素固定有四个(因为四个元素才能构成一个正方形)，我们还需要一层循环来确定每一层的组数，这个循环变量能够定位到每一组的第一个元素，并且内层循环能够限制每一层的组数。
- 我们拿最外层来举例子，最外层的元素一共有四组，开头元素分别是A、B、C、D，因此内层的循环变量每次++就可以移动到下一组，由于不同层的组数与层数有关，因此我们内层循环的限制要与外层循环的变量有关。
- 我们现在来分析整个算法的循环公式，由于这个循环肯定具有普遍性，因此我们值需要分析具有普遍性的一组，我们可以分析最外层的第二组：
	- [0],[1]——[1],[4]    [1],[4]——[4],[3]    [4],[3]——[3],[0]    [3],[0]——[0],[1]
	- 我们现在假设外层循环变量是i，内层循环变量是j，由于层数的不同，每一层第一组元素首元素的下标也不一样，因此i与j是相互关联的，我们很容易得出在每一层的计算中，j在一开始都应该等于i。
	- 最外层的第二组中，i = 0；j = 1；
	- 因此[0],[1]对应[i],[j]， [1],[4]对应[j],[n - 1 - i]， [4],[3]对应[n - 1 - i],[n - j - 1]， [3],[0]对应[n - j - 1],[i]
	- 通过上面的坐标，我们可以发现row和col是相互循环的。
	- 现在我们拿最外层的第三组试验：此时i = 0；j = 2
	- [0],[2] 、[2],[4] 、[4],[2] 、[2],[0]，这与我们上面推出来的公式正好吻合。
##### 4.代码实现：
```cpp
void Rotate(int (*list)[order], const int n)
{
	for (int i = 0 ; i < n / 2 ; i++)//number of floor
	{
		for (int j = i ; j < n - 1 - i ; j++)//number of start and end restriction
		{
			int temp = list[i][j];
			list[i][j] = list[n - j - 1][i];
			list[n - j - 1][i] = list[n - i - 1][n - j - 1];
			list[n - i - 1][n - j - 1] = list[j][n - i - 1];
			list[j][n - i - 1] = temp;
		}
	}
	return;
}
```
